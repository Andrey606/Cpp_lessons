#include <iostream>
#include <string>

struct String
{
public:
    String(String && s) // && - rvalue reference
        : data_(s.data_)
        , size_(s.size_)
    {
        s.data_ = nullptr;
        s.size_ = 0;
    }
    String& operator = (String && s)
    {
        delete [] data_;
        data_ = s.data_;
        size_ = s.size_;
        s.data_ = nullptr;
        s.size_ = 0;
        return *this;
    }
public:
    char* data_;
    int size_;
};

std::string getCurrentDateString()
{
    std::string date;
    // date заполняем "21 октября 2015 года"
    return std::move(date); // тут не будет копирование в возвращаемое значение функции благодаря стд мув, а будет перемещение
    // использовать стд::мув не обязательно, читай ниже
}

/*
Когда вызываются перемещающие методы

В примере на предыдущем степе можно было не использовать std::move. Дело в том, что при возвращении локального объекта функции (каким и является date) по значению будет вызываться перемещающий конструктор. Т.е. код функции можно было оставить без изменения.

String getCurrentDateString()
{
    String date;
    // date заполняется "21 октября 2015 года"

    // без std::move 
    return date; // date будет перемещена
}
Более того, такой код потенциально работает более эффективно: так как в данном случае компилятору позволяется сделать оптимизацию возвращаемого значения (RVO).
Вот неполный список случаев, когда будут вызываться перемещающие методы:

!!!!если передавать в них объект при помощи std::move();
!!!!если передавать в них временный объект (обьект возвращенный от функции);
!!!!если из функции по значению возвращается локальный объект функции.

Некоторые другие случаи, в которых вызываются перемещающие методы, мы увидим в дальнейшем в этом курсе.
*/

int main(int argc, const char * argv[]) 
{
    std::string date = getCurrentDateString(); // а тут будет вызван конструктор перемещение и тоже копирование не будет

    return 0;
}