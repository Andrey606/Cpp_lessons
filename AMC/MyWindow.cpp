//===================================================================
// COPYRIGHT amcbridge 2021/03/26
//===================================================================
// MyWindow.cpp
// Header definition of class MyWindow
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2021/03/26 Creation: Code generated by the 3DS wizard
//===================================================================
// У меня уже есть директива препроцессора в верхней части моего файла, чтобы включить визуальные стили.
#pragma comment(linker,"\"/manifestdependency:type='win32' \
name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"") 

#include "MyWindow.h"

#include "CATDlgNotify.h"
#include "CATApplicationFrame.h"
#include "CATDlgSeparatorItem.h"
#include "CATDialog.h"
#include "CATCreateExternalObject.h"
#include "CATListOfCATUnicodeString.h"
#include "CATDlgGridConstraints.h"
#include "CATDlgContainer.h"
#include "CATDlgLabel.h"
#include "CATDlgPushButton.h"


#define no_init_all
#include <Windows.h>
#include <iostream>
#include <tchar.h>
#include <Commctrl.h>


//-----------------------------------------------------------------------------
// MyWindow : constructor
//-----------------------------------------------------------------------------
MyWindow::MyWindow(CATDialog * iParent, const CATString& iDialogName) 
	: CATDlgDialog(iParent, iDialogName, CATDlgWndNoButton)
{

}

#define UNUSED(expr) (void)(expr)

struct Image
{
	HBITMAP hBitmap;
	LONG width, height;
};

static HDC hdcMemSurface;
static struct Image images[2];


static struct Image loadImage(LPCTSTR path, HINSTANCE hInstance)
{
	struct Image image;

	image.hBitmap = (HBITMAP)LoadImage(
		hInstance,
		path,
		IMAGE_BITMAP,
		0, 0,
		LR_LOADFROMFILE | LR_CREATEDIBSECTION
	);

	BITMAP bitmapInfo;
	GetObject(image.hBitmap, sizeof(bitmapInfo), &bitmapInfo);
	image.width = bitmapInfo.bmWidth;
	image.height = bitmapInfo.bmHeight;

	return image;
}


HBRUSH CreateGradientBrush(COLORREF top, COLORREF bottom, LPNMCUSTOMDRAW item)
{
	HBRUSH Brush = NULL;
	HDC hdcmem = CreateCompatibleDC(item->hdc);
	HBITMAP hbitmap = CreateCompatibleBitmap(item->hdc, item->rc.right - item->rc.left, item->rc.bottom - item->rc.top);
	SelectObject(hdcmem, hbitmap);

	int r1 = GetRValue(top), r2 = GetRValue(bottom), g1 = GetGValue(top), g2 = GetGValue(bottom), b1 = GetBValue(top), b2 = GetBValue(bottom);
	for (int i = 0; i < item->rc.bottom - item->rc.top; i++)
	{
		RECT temp;
		int r, g, b;
		r = int(r1 + double(i * (r2 - r1) / item->rc.bottom - item->rc.top));
		g = int(g1 + double(i * (g2 - g1) / item->rc.bottom - item->rc.top));
		b = int(b1 + double(i * (b2 - b1) / item->rc.bottom - item->rc.top));
		Brush = CreateSolidBrush(RGB(r, g, b));
		temp.left = 0;
		temp.top = i;
		temp.right = item->rc.right - item->rc.left;
		temp.bottom = i + 1;
		FillRect(hdcmem, &temp, Brush);
		DeleteObject(Brush);
	}
	HBRUSH pattern = CreatePatternBrush(hbitmap);

	DeleteDC(hdcmem);
	DeleteObject(Brush);
	DeleteObject(hbitmap);

	return pattern;
}


HWND Label0, Label1, Label2;
HWND Button0, Button1, Button2;

#define IDC_EXIT_BUTTON 101
#define IDC_PUSHLIKE_BUTTON 102

#define button1 1
#define button2 2
#define button3 3
int winApiTest3()
{
	MSG msg{};
	HWND hwnd{};
	WNDCLASSEX wc{ sizeof(WNDCLASSEX) };
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hbrBackground = reinterpret_cast<HBRUSH>(GetStockObject(WHITE_BRUSH));
	wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
	wc.hIcon = LoadIcon(nullptr, TEXT("IDI_ICON1"));
	wc.hIconSm = LoadIcon(nullptr, IDI_APPLICATION);
	wc.hInstance = NULL;
	wc.lpfnWndProc = [](HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)->LRESULT
	{
		static HBRUSH hBrush;
		static RECT r;
		HDC hDC;
		static int nHDif = 0, nVDif = 0, nHPos = 0, nVPos = 0;

		HBRUSH g_hbrBackground = CreateSolidBrush(RGB(0, 0, 0));

		// lines 
		static HPEN LinePen;
		static BOOL fDraw = FALSE;
		static POINT ptPrevious = { 0, 0 };

		//RECT textRect;
		static HPEN RectPen;

		static LOGFONT lf;

		static HBRUSH defaultbrush = NULL;
		static HBRUSH hotbrush = NULL;
		static HBRUSH selectbrush = NULL;
		static HBRUSH push_uncheckedbrush = NULL;
		static HBRUSH push_checkedbrush = NULL;
		static HBRUSH push_hotbrush1 = NULL;
		static HBRUSH push_hotbrush2 = NULL;

		switch (uMsg)
		{

		case WM_NOTIFY:
		{
			LPNMHDR some_item = (LPNMHDR)lParam;

			if (some_item->idFrom == IDC_EXIT_BUTTON && some_item->code == NM_CUSTOMDRAW)
			{
				LPNMCUSTOMDRAW item = (LPNMCUSTOMDRAW)some_item;

				if (item->uItemState & CDIS_SELECTED)
				{
					//Select our color when the button is selected
					if (selectbrush == NULL)
						selectbrush = CreateGradientBrush(RGB(33, 180, 243), RGB(33, 180, 243), item); // это цвет когда кнопка нажата (кликнута) Сancel

					//Create pen for button border
					HPEN pen = CreatePen(PS_NULL, 0, RGB(0, 0, 0));

					//Select our brush into hDC
					HGDIOBJ old_pen = SelectObject(item->hdc, pen);
					HGDIOBJ old_brush = SelectObject(item->hdc, selectbrush);

					//If you want rounded button, then use this, otherwise use FillRect().
					RoundRect(item->hdc, item->rc.left, item->rc.top, item->rc.right, item->rc.bottom, 15, 15);

					//Clean up
					SelectObject(item->hdc, old_pen);
					SelectObject(item->hdc, old_brush);
					DeleteObject(pen);

					//Now, I don't want to do anything else myself (draw text) so I use this value for return:
					return CDRF_DODEFAULT;
					//Let say I wanted to draw text and stuff, then I would have to do it before return with
					//DrawText() or other function and return CDRF_SKIPDEFAULT
				}
				else
				{
					if (item->uItemState & CDIS_HOT) //Our mouse is over the button
					{
						//Select our color when the mouse hovers our button
						if (hotbrush == NULL)
							hotbrush = CreateGradientBrush(RGB(33, 180, 243), RGB(33, 180, 243), item); // меняе цыет когда курсор над мышкой  Cancel

						HPEN pen = CreatePen(PS_NULL, 0, RGB(0, 0, 0));

						HGDIOBJ old_pen = SelectObject(item->hdc, pen);
						HGDIOBJ old_brush = SelectObject(item->hdc, hotbrush);

						RoundRect(item->hdc, item->rc.left, item->rc.top, item->rc.right, item->rc.bottom, 15, 15);

						SelectObject(item->hdc, old_pen);
						SelectObject(item->hdc, old_brush);
						DeleteObject(pen);

						return CDRF_DODEFAULT;
					}

					//Select our color when our button is doing nothing
					if (defaultbrush == NULL)
						defaultbrush = CreateGradientBrush(RGB(33, 150, 243), RGB(33, 150, 243), item); //цвет кнопок когда ничег не происходит

					HPEN pen = CreatePen(PS_NULL, 0, RGB(0, 0, 0));

					HGDIOBJ old_pen = SelectObject(item->hdc, pen);
					HGDIOBJ old_brush = SelectObject(item->hdc, defaultbrush);

					RoundRect(item->hdc, item->rc.left, item->rc.top, item->rc.right, item->rc.bottom, 15, 15);

					SelectObject(item->hdc, old_pen);
					SelectObject(item->hdc, old_brush);
					DeleteObject(pen);

					return CDRF_DODEFAULT;
				}
			}
			else if (some_item->idFrom == IDC_PUSHLIKE_BUTTON && some_item->code == NM_CUSTOMDRAW)
			{
				LPNMCUSTOMDRAW item = (LPNMCUSTOMDRAW)some_item;

				if (IsDlgButtonChecked(hwnd, some_item->idFrom))
				{
					if (item->uItemState & CDIS_HOT)
					{

						if (push_hotbrush1 == NULL)
							push_hotbrush1 = CreateGradientBrush(RGB(0, 0, 245), RGB(0, 230, 255), item);

						HPEN pen = CreatePen(PS_NULL, 0, RGB(0, 0, 0));

						HGDIOBJ old_pen = SelectObject(item->hdc, pen);
						HGDIOBJ old_brush = SelectObject(item->hdc, push_hotbrush1);

						RoundRect(item->hdc, item->rc.left, item->rc.top, item->rc.right, item->rc.bottom, 15, 15);

						SelectObject(item->hdc, old_pen);
						SelectObject(item->hdc, old_brush);
						DeleteObject(pen);

						return CDRF_DODEFAULT;
					}


					if (push_checkedbrush == NULL)
						push_checkedbrush = CreateGradientBrush(RGB(0, 0, 180), RGB(0, 222, 200), item);


					HPEN pen = CreatePen(PS_NULL, 0, RGB(0, 0, 0));


					HGDIOBJ old_pen = SelectObject(item->hdc, pen);
					HGDIOBJ old_brush = SelectObject(item->hdc, push_checkedbrush);


					RoundRect(item->hdc, item->rc.left, item->rc.top, item->rc.right, item->rc.bottom, 15, 15);


					SelectObject(item->hdc, old_pen);
					SelectObject(item->hdc, old_brush);
					DeleteObject(pen);


					return CDRF_DODEFAULT;
				}
				else
				{
					if (item->uItemState & CDIS_HOT)
					{
						if (push_hotbrush2 == NULL)
							push_hotbrush2 = CreateGradientBrush(RGB(33, 180, 243), RGB(33, 180, 243), item); // когда нажали repeat uploading 

						HPEN pen = CreatePen(PS_NULL, 0, RGB(0, 0, 0));

						HGDIOBJ old_pen = SelectObject(item->hdc, pen);
						HGDIOBJ old_brush = SelectObject(item->hdc, push_hotbrush2);

						RoundRect(item->hdc, item->rc.left, item->rc.top, item->rc.right, item->rc.bottom, 15, 15);

						SelectObject(item->hdc, old_pen);
						SelectObject(item->hdc, old_brush);
						DeleteObject(pen);

						return CDRF_DODEFAULT;
					}

					if (push_uncheckedbrush == NULL)
						push_uncheckedbrush = CreateGradientBrush(RGB(255, 180, 0), RGB(180, 0, 0), item);

					HPEN pen = CreatePen(PS_INSIDEFRAME, 0, RGB(0, 0, 0));

					HGDIOBJ old_pen = SelectObject(item->hdc, pen);
					HGDIOBJ old_brush = SelectObject(item->hdc, defaultbrush);

					RoundRect(item->hdc, item->rc.left, item->rc.top, item->rc.right, item->rc.bottom, 15, 15);

					SelectObject(item->hdc, old_pen);
					SelectObject(item->hdc, old_brush);
					DeleteObject(pen);

					return CDRF_DODEFAULT;
				}
			}
			return CDRF_DODEFAULT;
		}
		break;

		case WM_COMMAND:
			if (LOWORD(wParam) == 1 || LOWORD(wParam) == 2 || LOWORD(wParam) == 3)
			{
				PostQuitMessage(0);
			}

			return 0;

		case WM_NCHITTEST:
		{
			//std::cout << "WM_NCHITTEST" << std::endl;
			LRESULT currentArea = DefWindowProc(hwnd, uMsg, wParam, lParam);
			if (HTCLIENT == currentArea)
				return HTCAPTION;
			return currentArea;
		}

		//case WM_INITDIALOG:
		//{
			//HICON hIcon1 = LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_ICON1));
			//SendMessage(hwnd, WM_SETICON, 1, (LPARAM)hIcon1);
		//}
		//return 0;

		case WM_CTLCOLORBTN:
		{
			//SetTextColor((HDC)wParam, RGB(244, 0, 0));
			//return (LRESULT)CreateSolidBrush(RGB(255, 255, 0));
			return 0;
		}

		case WM_CTLCOLOREDIT:
		{
			if (lParam == (LPARAM)Label1)
			{
				hDC = (HDC)wParam;

				//SetTextColor(hDC, RGB(242, 139, 47));	// red
			}
			//SetBkColor(hDC, RGB(255, 255, 0));	// yellow
			//return (LRESULT)CreateSolidBrush(RGB(0, 0, 0));
			return 0;
		}

		case WM_NCCALCSIZE:
			return 0;

		case WM_CREATE:
		{

			HWND Exit_Button2 = CreateWindowEx(NULL, TEXT("BUTTON"), TEXT("×"),
				WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
				562, 13 - 3, 24, 24, hwnd, (HMENU)IDC_EXIT_BUTTON, NULL, NULL);
			if (Exit_Button2 == NULL)
			{
				MessageBox(NULL, TEXT("Button Creation Failed!"), TEXT("Error!"), MB_ICONEXCLAMATION);
				exit(EXIT_FAILURE);
			}


			HWND Exit_Button = CreateWindowEx(NULL, TEXT("BUTTON"), TEXT("Cancel"),
				WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
				16, 191, 69, 22, hwnd, (HMENU)IDC_EXIT_BUTTON, NULL, NULL);
			if (Exit_Button == NULL)
			{
				MessageBox(NULL, TEXT("Button Creation Failed!"), TEXT("Error!"), MB_ICONEXCLAMATION);
				exit(EXIT_FAILURE);
			}

			HWND Pushlike_Button = CreateWindowEx(NULL, TEXT("BUTTON"), TEXT("Repeat Uploading"),
				WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX | BS_PUSHLIKE,
				451, 191, 130, 22, hwnd, (HMENU)IDC_PUSHLIKE_BUTTON, NULL, NULL);
			if (Pushlike_Button == NULL)
			{
				MessageBox(NULL, TEXT("Button Creation Failed!"), TEXT("Error!"), MB_ICONEXCLAMATION);
				exit(EXIT_FAILURE);
			}
			//Label0 = CreateWindow(TEXT("STATIC"), TEXT("Share for Review in Colab"), WS_CHILD | WS_VISIBLE | SS_BLACKFRAME | SS_CENTER, 74, 14, 193+40, 22, hwnd, 0, 0, 0);
			//Label1 = CreateWindow(TEXT("EDIT"), TEXT("Uploading failed."), WS_CHILD | WS_VISIBLE, 240, 82, 120+40, 19+5, hwnd, 0, 0, 0);
			//Label2 = CreateWindow(TEXT("EDIT"), TEXT("Try to repeat the upload or return to uploading later."), WS_CHILD | WS_VISIBLE, 101, 113, 397+30, 19+5, hwnd, 0, 0, 0);

			
			SendMessage(Exit_Button, WM_SETFONT, (LPARAM)GetStockObject(DEFAULT_GUI_FONT), true);
			SendMessage(Pushlike_Button, WM_SETFONT, (LPARAM)GetStockObject(DEFAULT_GUI_FONT), true);

			//SendMessage(Label0, WM_SETFONT, (LPARAM)GetStockObject(DEFAULT_GUI_FONT), true);
			//SendMessage(Label1, WM_SETFONT, (LPARAM)GetStockObject(DEFAULT_GUI_FONT), true);
			//SendMessage(Label2, WM_SETFONT, (LPARAM)GetStockObject(DEFAULT_GUI_FONT), true);

			const HINSTANCE hInstance = (HINSTANCE)GetWindowLong(hwnd, -6);

			images[0] = loadImage(TEXT("icon12.bmp"), hInstance);
			//images[0] = loadImage(TEXT("icon.bmp"), hInstance);

			const HDC hdcWin = GetDC(hwnd);
			hdcMemSurface = CreateCompatibleDC(hdcWin);
			ReleaseDC(hwnd, hdcWin);

			return 0;
		}

		case WM_PAINT:
		{
			PAINTSTRUCT ps;
			const HDC hdc = BeginPaint(hwnd, &ps);

			// icon
			int x = 14;
			int y = 7;
			for (size_t i = 0; i < 1; ++i)
			{
				SelectObject(hdcMemSurface, images[i].hBitmap);
				BitBlt(
					hdc,
					x, y,
					images[i].width, images[i].height,
					hdcMemSurface,
					0, 0,
					SRCCOPY
				);

#define GAP 3
				x += images[i].width + GAP;
				y += images[i].height + GAP;
			}

			// lines
			LinePen = CreatePen(PS_SOLID, 1, RGB(78, 80, 85));
			SelectObject(hdc, LinePen);
			MoveToEx(hdc, 60, 0, (LPPOINT)NULL);
			LineTo(hdc, 60, 49);

			MoveToEx(hdc, 0, 49, (LPPOINT)NULL);
			LineTo(hdc, 600, 49);

			//RectPen = CreatePen(PS_SOLID, 1, RGB(241, 242, 246));
			//SelectObject(hdc, RectPen);
			//SetBkColor(hdc, RGB(241, 242, 246)); 
			//Rectangle(hdc, 0, 175, 600, 234);


			//рисуем красный прямоугольник
			r.top = 175;
			r.left = 0;
			r.right = 600;
			r.bottom = 234;
			FillRect(hdc, &r, HBRUSH(CreateSolidBrush(RGB(241, 242, 246))));

			SetBkMode(hdc, TRANSPARENT);
			SetTextColor(hdc, NULL);
			TextOut(hdc, 74, 14, TEXT("Share for Review in Colab"), strlen("Share for Review in Colab"));

			SetTextColor(hdc, RGB(242, 139, 47));
			TextOut(hdc, 240, 82, TEXT("Uploading failed."), strlen("Uploading failed."));

			SetTextColor(hdc, NULL);
			TextOut(hdc, 101, 113, TEXT("Try to repeat the upload or return to uploading later."), strlen("Try to repeat the upload or return to uploading later."));

			EndPaint(hwnd, &ps);
			return 0;
		}


		return 0;

		}
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	};
	wc.lpszClassName = TEXT("MyAppClass");
	wc.lpszMenuName = nullptr;
	wc.style = CS_VREDRAW | CS_HREDRAW;

	if (!RegisterClassEx(&wc))
		return EXIT_FAILURE;

	hwnd = CreateWindow(wc.lpszClassName, TEXT("Share for Review in Colab"), WS_POPUP, 400, 300, 600, 234, nullptr, nullptr, wc.hInstance, nullptr);
	if (hwnd == INVALID_HANDLE_VALUE)
		return EXIT_FAILURE;

	//Button0 = CreateWindow(TEXT("button"), TEXT("×"), WS_VISIBLE | WS_CHILD, 562, 13 - 3, 24, 24, hwnd, (HMENU)button1, NULL, NULL);
	//Button1 = CreateWindow(TEXT("button"), TEXT("Cancel"), WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS, 16, 191, 70, 24+5, hwnd, (HMENU)button2, NULL, NULL);
	//Button2 = CreateWindow(TEXT("button"), TEXT("Repeat Uploading"), WS_VISIBLE | WS_CHILD, 451-27, 191, 140+20, 24+5, hwnd, (HMENU)button3, NULL, NULL);

	ShowWindow(hwnd, SW_SHOW); //Светим окно
	UpdateWindow(hwnd);

	while (GetMessage(&msg, nullptr, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	return static_cast<int>(msg.wParam);
}


void MyWindow::Build()
{
	winApiTest3();


	void *var = this->GetWindowHandle();

	/*this->SetDefaultButton(NULL);
	this->SetTitle("Proto Sample");
	this->SetRectDimensions(330, 330, 100, 250);

	PushButton1111 = new CATDlgPushButton(this, "ThePushButton");
	CATDlgLabel *testLabel = new CATDlgLabel(this, "Label");

	unsigned char con[] = { "IDB_BITMAP1" };
	PushButton1111->SetIconBitmap(con, 22,22);
	testLabel->SetIconBitmap(con, 22, 22);



	//PushButton1111->SetTitle("Apply");

	this->SetVisibility(CATDlgShow);*/
}

//-----------------------------------------------------------------------------
// MyWindow : destructor
//-----------------------------------------------------------------------------

MyWindow::~MyWindow()
{
//
// TODO: Place code here.
//
}


